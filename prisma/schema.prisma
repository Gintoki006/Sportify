// Sportify — Prisma Schema
// Docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ── Enums ──

enum SportType {
  FOOTBALL
  CRICKET
  BASKETBALL
  BADMINTON
  TENNIS
  VOLLEYBALL
}

enum StatSource {
  MANUAL
  TOURNAMENT
}

enum TournamentStatus {
  UPCOMING
  IN_PROGRESS
  COMPLETED
}

enum ClubRole {
  ADMIN
  HOST
  PARTICIPANT
  SPECTATOR
}

// ── Models ──

model User {
  id        String   @id @default(cuid())
  clerkId   String   @unique
  name      String
  email     String   @unique
  avatarUrl String?
  bio       String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sportProfiles SportProfile[]
  clubs         ClubMember[]
  adminClubs    Club[]         @relation("ClubAdmin")
  roleRequests  RoleUpgradeRequest[]
  matchesAsPlayerA Match[]    @relation("PlayerA")
  matchesAsPlayerB Match[]    @relation("PlayerB")
  tournamentPlayers TournamentPlayer[]
}

model SportProfile {
  id        String   @id @default(cuid())
  userId    String
  sportType SportType
  createdAt DateTime @default(now())

  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  stats   StatEntry[]
  goals   Goal[]

  @@unique([userId, sportType])
}

model StatEntry {
  id             String     @id @default(cuid())
  sportProfileId String
  date           DateTime   @default(now())
  opponent       String?
  notes          String?
  metrics        Json       // sport-specific metrics stored as JSON
  source         StatSource @default(MANUAL)
  matchId        String?    // if sourced from a tournament match
  createdAt      DateTime   @default(now())

  sportProfile SportProfile @relation(fields: [sportProfileId], references: [id], onDelete: Cascade)
  match        Match?       @relation(fields: [matchId], references: [id])
}

model Goal {
  id             String   @id @default(cuid())
  sportProfileId String
  metric         String   // e.g. "goals", "runs", "points_scored"
  target         Int
  current        Int      @default(0)
  deadline       DateTime?
  completed      Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  sportProfile SportProfile @relation(fields: [sportProfileId], references: [id], onDelete: Cascade)
}

model Club {
  id          String   @id @default(cuid())
  name        String
  description String?
  adminUserId String
  createdAt   DateTime @default(now())

  admin       User         @relation("ClubAdmin", fields: [adminUserId], references: [id])
  members     ClubMember[]
  tournaments Tournament[]
  roleRequests RoleUpgradeRequest[]
}

model ClubMember {
  id       String   @id @default(cuid())
  userId   String
  clubId   String
  role     ClubRole @default(SPECTATOR)
  joinedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  club Club @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([userId, clubId])
}

model RoleUpgradeRequest {
  id          String   @id @default(cuid())
  userId      String
  clubId      String
  requestedRole ClubRole
  status      RequestStatus @default(PENDING)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  club Club @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([userId, clubId, status])
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model Tournament {
  id        String           @id @default(cuid())
  clubId    String
  name      String
  sportType SportType
  startDate DateTime
  endDate   DateTime?
  status    TournamentStatus @default(UPCOMING)
  createdAt DateTime         @default(now())

  club    Club    @relation(fields: [clubId], references: [id], onDelete: Cascade)
  matches Match[]
  players TournamentPlayer[]
}

model Match {
  id           String   @id @default(cuid())
  tournamentId String
  round        Int
  teamA        String
  teamB        String
  playerAId    String?  // linked User for teamA (optional for legacy/custom names)
  playerBId    String?  // linked User for teamB (optional for legacy/custom names)
  scoreA       Int?
  scoreB       Int?
  date         DateTime?
  completed    Boolean  @default(false)
  createdAt    DateTime @default(now())

  tournament Tournament  @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  playerA    User?        @relation("PlayerA", fields: [playerAId], references: [id], onDelete: SetNull)
  playerB    User?        @relation("PlayerB", fields: [playerBId], references: [id], onDelete: SetNull)
  statEntries StatEntry[]
}

model TournamentPlayer {
  id           String   @id @default(cuid())
  tournamentId String
  userId       String
  seed         Int      // bracket slot (0-based)
  createdAt    DateTime @default(now())

  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, userId])
  @@unique([tournamentId, seed])
}
